# [Day2] 유클리드 호제법, 소수 판별법

###  약수
+ 어떠한 수를 나누어떨어지게 하는 수
+ N의 약수의 개수를 구하는 방법
  + 방법1) 1부터 N 이하의 정수로 N을 나누어서, 나머지가 0이 되는 수의 개수를 찾기
    + 시간 복잡도: O(N)
  + 방법2) 1부터 √N 이하의 정수로 N을 나누어서, 나머지가 0이 되는 수의 개수를 찾고 그 개수에 2를 곱함, N이 제곱수이면 -1를 함
    + 시간 복잡도: O(√N)

### 유클리드 호제법
+  정수의 최대공약수(GCD, Greatest Common Divisor)를 구하는 알고리즘

#### 예시
+ 최대공약수 구하기
```java
public static int GCD(int a, int b) {
    while (b != 0) {
        int tmp = b;
        b = a % b;
        a = tmp;
    }
    return a;
}
```
+ 최소공배수 구하기
```java
public static int LCM(int a, int b) {
    int gcd = GCD(a,b);
    return (a *b) / gcd;
}
```

### 소수
+ 1과 자기 자신으로만 나누어지는 수
+ 1은 소수가 아님
+ 소수를 찾는 방법
  + 방법1) 1부터 N까지의 수로 N을 나눔
    + 시간 복잡도: O(N)
  + 방법2) 1부터 √N까지의 수로 N을 나눔
    + 시간 복잡도: O(√N)

### 에라토스테네스의 체
+ 소수를 찾는 알고리즘
+ 방법
```
1. 2부터 n까지의 숫자를 나열합니다.
2. 나열된 숫자 중 가장 작은 수인 2를 소수로 선택하고, 2의 배수들을 모두 지웁니다.
3. 남아있는 숫자 중 가장 작은 수를 소수로 선택하고, 그 수의 배수들을 모두 지웁니다.
4. 이 과정을 √N까지 반복합니다.
5. 남아있는 모든 숫자가 소수입니다.
```
+ 시간 복잡도: O(N log(log N))
+ 방법1, 방법2보다 시간복잡도가 낮음